# gpv23

**Prime-length NTT + RNS (double-CRT) sandbox for the GPV23 amortized bootstrapping technique (ePrint 2023/014).**

This repository is a *research prototype* focused on the **prime-length / circulant-ring arithmetic** that appears in:

> Antonio Guimarães, Hilder V. L. Pereira, Barry van Leeuwen  
> *Amortized bootstrapping revisited: Simpler, asymptotically-faster, implemented*  
> Cryptology ePrint Archive, Report 2023/014  
> https://eprint.iacr.org/2023/014

The original paper proposes an **amortized bootstrapping** procedure that refreshes **many LWE messages at once** and makes the per-message number of heavy homomorphic multiplications **sublinear**. A core ingredient is a **homomorphic inverse NTT** (INTT) evaluated “in the exponent” using **GSW-style ciphertexts encrypting monomials** `X^e` in a **prime-length cyclic ring**. This repo experiments with **faster FFT/NTT techniques** and **RNS prime selection** to improve performance over the baseline implementation.

> ⚠️ **Prototype status:** This code is **not** a complete bootstrapping implementation yet. Several cryptographic pieces are stubs (e.g., error sampling is zero, key switching is not a full gadget decomposition). Treat this as a fast-moving sandbox for arithmetic + transform ideas, not a production FHE library.

---

## Why this repo exists

The GPV23 paper’s implemented proof-of-concept demonstrates that amortized bootstrapping can be practical, but also notes that:
- the INTT/homomorphic transform is the dominant cost,
- memory can be the limiting factor (large keysets),
- careful parameter + modulus-chain engineering is required.

The original reference implementation (the authors’ “Amortized-Bootstrapping” repo) uses a padded power-of-two NTT size for the prime-length ring, which is convenient but potentially leaves performance on the table.

This repo (`gpv23`) is a place to explore:

1. **Prime-length FFT/NTT tricks**
   - Avoid padding `p=12289` up to `32768` (or similar) by using a transform that directly exploits the smoothness of `p-1=12288=2^12·3`.
   - Experiment with mixed-radix `2^u·3^v` kernels, tensor decompositions, Stockham autosort, etc.

2. **Prime selection / modulus engineering**
   - Select RNS primes `q_i` so that we have:
     - `q_i ≡ 1 (mod p)` and `q_i ≡ 1 (mod p-1)` (and often more),
     - good NTT friendliness (e.g., extra 2-adicity for other rings / kernels),
     - fewer limbs `ell` if possible (bigger primes) without breaking noise budgets.

3. **A clean, hackable arithmetic backend**
   - A templated, header-only-ish prime-length NTT (`include/ntt.h`)
   - A small DCRT polynomial type (`include/dcrtpoly.h`)
   - Minimal RLWE/RGSW-like ciphertext containers (`include/rlwe.h`) for algorithmic experiments

---

## Paper context in ~2 pages

This section is “the story” a new contributor should understand before touching code.

### Amortized bootstrapping (high-level)
Traditional bootstrapping refreshes **one** ciphertext at a time. Amortized bootstrapping refreshes **N ciphertexts at once** by packing them into one RLWE sample, doing a big batched computation, and then extracting refreshed outputs.

The GPV23 paper improves prior amortized bootstrapping asymptotically and practically by:
- reducing the per-message number of homomorphic multiplications,
- providing a simpler construction,
- implementing a double-CRT (RNS) GSW scheme plus a **shrinking** operation that reduces ciphertext modulus/dimension along the way,
- showing competitive concrete timings (the paper reports being ~3.4× faster than an equivalent non-amortized baseline in their setting).

### The “circulant ring” used by the transform
The paper’s GSW machinery is built over a **cyclic polynomial ring**:

- `R_p = Z_p[X] / (X^p - 1)` with **prime** `p`.

A key concrete choice in the implementation is:

- `p = 12289`, and a packed input RLWE dimension `N = 1024`,
- with the extra requirement that a `2N`-th root of unity exists modulo `p`.

Because `p-1 = 12288` is very smooth (`2^12·3`), transforms and automorphism schedules can be efficient.

### “In the exponent”: monomial plaintexts
Instead of encrypting a plaintext value `m` directly, the construction often encrypts a **monomial** `X^e`:

- plaintext space is the multiplicative group generated by `X` in `R_p`,
- multiplying ciphertexts adds exponents: `X^a · X^b = X^(a+b)`,
- automorphisms `X ↦ X^g` multiply exponents: `X^a ↦ X^(g·a)`.

This makes it possible to evaluate scalar products and NTT-style linear transforms *on exponents* using combinations of:
- GSW/RGSW homomorphic multiplication (via external products),
- automorphisms + key switching.

In the paper, this is formalized as **EvalScalarProd** (Algorithm 7).

### Homomorphic INTT as the core computation
A major algorithmic core is the **homomorphic evaluation of an inverse NTT** (Algorithm 8), implemented in a radix-`m` recursion with depth `ρ`.

Intuition:
- In clear, `INTT` turns point-values back into coefficients.
- Homomorphically, we can’t do cheap scalar multiplies and additions; we do them “in the exponent” via Algorithm 7.
- The recursion depth `ρ` trades:
  - work vs. noise growth,
  - and it is typically kept small in concrete instantiations.

### Bootstrapping pipeline (paper’s Algorithms 9–11)
At a very high level, the paper’s bootstrapping pipeline for `N` messages is:

1. **Pack** `N` LWE ciphertexts into one RLWE ciphertext (`PackLWE`)
2. **Modulus switch** that packed RLWE ciphertext from large modulus `Q` down to the prime `p`
3. **Partial decryption via NTT** (`NTTDec`, Algorithm 9):
   - compute forward NTT of `(a,b)` in clear
   - combine with a bootstrapping key that encrypts the secret in the NTT domain
   - apply **homomorphic inverse NTT** (Algorithm 8) to obtain GSW encryptions of `X^(Δ·m_i + e_i)`
4. **Message extraction** (`MsgExtract`, Algorithm 10) to get output LWE ciphertexts (optionally programmable via a LUT function `f`)

The paper’s reference implementation also includes significant engineering:
- a double-CRT (RNS) representation of ciphertexts,
- **shrinking** to drop primes/dimensions mid-computation,
- careful parameter selection to make the above practical.

---

## What is implemented in this repo

### ✅ Prime-length (circulant) NTT infrastructure
Implemented in `include/ntt.h`:

- `NTT<q, g, O, w>`:
  - Implements a transform of length `O-1` (with `O` prime),
  - with a mixed-radix Cooley–Tukey “CT23” kernel for `O-1 = 2^u · 3^v`,
  - AVX2 vectorization in the radix-2 stages,
  - and permutations based on a generator `w` of `(Z/OZ)^*`.

- `CircNTT<q, g, O, w>`:
  - Wraps the `O-1` primitive transform to provide a transform of length `O` (the “circulant”/prime-length NTT used for `R_p = Z_q[X]/(X^O-1)`).
  - For `O = p = 12289`, this gives an NTT for polynomials mod `X^p-1`.

- `TensorNTTImpl<NTTp, NTTq>`:
  - A 2D / tensor decomposition helper for composite sizes.
  - Useful if you want to explicitly do `12288 = 4096×3` as a matrix NTT.

**Important parameter constraint:**  
`NTT<q,g,O,w>` enforces `q ≡ 1 (mod O·(O-1))` so that the needed roots-of-unity exist for both the `O`- and `(O-1)`-related subtransforms.

### ✅ DCRT polynomial container
Implemented in `include/dcrtpoly.h`:

- `DCRTPoly<NTT1, NTT2, ...>` stores a polynomial in **RNS/DCRT form** across `ell` primes (one per `NTT` type).
- Storage layout: `a[ell][N]` where `N` is the polynomial length (e.g., `12289`) and each limb is stored in **NTT domain** for fast pointwise multiplication.
- Provides:
  - `operator+/-/*` (NTT-domain pointwise ops),
  - `BaseExtend<NTT>()` (slow, via inverse transform + reduce + forward transform),
  - `ModulusSwitch<NTT>()` (reconstruct/debug one modulus; not a full modulus-chain primitive),
  - `Galois(alpha)` permutations (a.k.a. automorphisms) for both `N==O` and `N==O-1` variants,
  - `Monomial(e, a)` helper to build `a·X^e`.

### ✅ Minimal RLWE / RGSW-ish skeleton
Implemented in `include/rlwe.h`:

- `RLWEEncrypt(m,s)`, `RGSWEncrypt(m,s)` and an `ExtMult` external-product-like operation.
- `Galois(...)` and `KeySwitch(...)` scaffolding to mimic the automorphism + key-switch pattern used in the paper.

**Caveat:** this is currently an *algorithmic scaffold*, not a full cryptographically correct implementation:
- `DCRTPoly::SampleE()` currently returns **zero** (no noise).
- `KeySwitch` / `KeySwitchGen` do not implement a real gadget decomposition.
- Decryption helpers are intended for sanity-check demos, not correctness/security claims.

### ✅ Demos, tests, benchmarks
- `src/main.cpp`:
  - A toy experiment that encrypts monomials and performs a homomorphic partial inverse transform schedule (`HomomorphicPFT`) using repeated `Galois + KeySwitch + ExtMult`.
  - This is conceptually related to the paper’s “INTT + EvalScalarProd” structure, but **not** an end-to-end bootstrap.

- `tests/ntt_tests.cpp`:
  - Small GoogleTest checks for compile-time invariants and permutation tables.

- `benchmarks/benchmark.cpp`:
  - Microbenchmarks for:
    - the CT23 kernel,
    - Rader/prime-length NTT sizes (97, 769, 12289),
    - `BaseExtend`,
    - `ExtMult`.

---

## Repository layout

```
gpv23/
  CMakeLists.txt
  include/
    zp.h         # Z_p arithmetic (+ Barrett helpers)
    ntt.h        # NTT<...>, CircNTT<...>, TensorNTTImpl<...>
    poly.h       # Polynomial wrapper over an NTT type (coeff <-> NTT domain)
    dcrtpoly.h   # DCRTScalar + DCRTPoly (RNS polynomials)
    rlwe.h       # RLWE / RGSW scaffolding + external product pattern
  src/
    main.cpp     # Demo: monomial encryption + homomorphic PFT schedule
  scripts/
    gen.sage     # Find NTT-friendly ~49-bit primes q_i and primitive roots
  tests/
    ntt_tests.cpp
    CMakeLists.txt
  benchmarks/
    benchmark.cpp
    CMakeLists.txt
```

---

## Building

### Prerequisites
- C++23 compiler (tested with GCC/Clang that support C++23)
- AVX2-capable CPU (build flags enable `-mavx2`)
- CMake ≥ 3.16
- (Optional) SageMath for prime generation (`scripts/gen.sage`)
- (Optional) Internet access during configure step:
  - tests download GoogleTest via `FetchContent`
  - benchmarks download Google Benchmark via `FetchContent`

> If you need fully offline builds, vendor the dependencies or replace FetchContent with system packages.

### Build commands

```bash
mkdir -p build
cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build . -j
```

Run the demo:

```bash
./gpv23
```

Run tests:

```bash
ctest --output-on-failure
```

Run benchmarks (if enabled):

```bash
./gpv23_benchmarks
```

---

## Known rough edges (prototype warnings)

A few practical notes for anyone hacking on this code:

- **CMake typo:** the top-level `CMakeLists.txt` currently uses `CMAKE_CXX_STANDARD_QUIRED` (typo).  
  Most toolchains ignore it; if you want strict behavior, change it to `CMAKE_CXX_STANDARD_REQUIRED`.

- **Tests/benchmarks fetch dependencies:** `tests/` and `benchmarks/` use `FetchContent` to clone
  GoogleTest / Google Benchmark at configure time. This requires network access. For offline builds,
  vendor the deps or switch to system packages.

- **Tests/benchmarks link against an executable:** both currently link against `${PROJECT_NAME}`
  which is an **executable** target. A more standard structure is to create `add_library(gpv23_core …)`
  and have `gpv23`, `gpv23_tests`, and `gpv23_benchmarks` link against the library.

- **Two different `Poly` classes:** there is a `Poly<NTT>` in `include/poly.h` and a `Poly<N>` in
  `include/dcrtpoly.h`. This is easy to confuse—consider namespacing/renaming when extending.

- **Thread safety:** some NTT routines use `static` scratch buffers (e.g., `static uint64_t reg[N];`).
  This is fine for single-threaded experiments but is not re-entrant/thread-safe.

- **Crypto stubs:** `SampleE()` currently returns zero noise and key switching is not a full gadget
  decomposition. Treat any “encryption” in this repo as *structural*, not secure/correct.

---

## Prime generation (`scripts/gen.sage`)

The transform types are templated as:

```cpp
using NTTi = CircNTT<q_i, g_i, O, w>;
```

where:

- `O` is the transform length (usually `O = p = 12289`),
- `w` is a primitive root modulo `O` (for 12289, the script prints this),
- `q_i` is an RNS prime modulus used for ciphertext arithmetic,
- `g_i` is a primitive root modulo `q_i`.

The Sage script searches for primes near `2^49` with:

- `q_i ≡ 1 (mod p·(p-1)·17)` (and also a small power-of-two factor),
- so that roots-of-unity of the desired orders exist.

Run:

```bash
sage scripts/gen.sage
```

It prints:
- factorization of `q_i - 1` (useful to sanity-check smoothness),
- the tuple you can paste into C++ template parameters.

---

## Key concepts & invariants for contributors

### Domain discipline: coefficient vs NTT
There are two different `Poly` types in this repo:

- `include/poly.h`: `template<typename NTT> class Poly`
  - owns a length-`NTT::N` array `a[]` and a flag `is_coeff`.
  - supports `ToCoeff()` / `ToNTT()` and pointwise ops in NTT domain.

- `include/dcrtpoly.h`: `template<size_t N> class Poly`
  - a *coefficient* container with signed `int64_t` entries, used to build `DCRTPoly`.

**Gotcha:** They currently share the same name `Poly`. Consider renaming/namespacing if you extend the repo.

### RNS/DCRT shape
`DCRTPoly<NTT1,...,NTT_ell>` stores `ell` limbs, one per modulus `q_i`, all with the same polynomial length.

- Construction from coefficient poly:
  - reduces coefficients modulo each `q_i`
  - transforms each limb to NTT domain
- Multiplication:
  - is pointwise multiplication per limb

### Automorphisms (Galois)
`DCRTPoly::Galois(alpha)` permutes coefficients/NTT slots according to multiplication by `alpha` in the index group.

This is the core mechanism used in GPV23 to implement exponent multiplication via `X ↦ X^alpha`.

### What is missing (roadmap toward paper reproduction)
To turn this repo into a faithful reproduction of the GPV23 amortized bootstrapping implementation, we still need (at least):

1. **Noise / sampling**
   - implement `SampleE()` (e.g., centered binomial)
   - enforce decryptability bounds and track noise growth

2. **Real gadget decomposition + key switching**
   - define gadget base(s), digit decomposition, scaling
   - implement RLWE/GSW key switching correctly

3. **Modulus chain support**
   - RNS base reduction (“drop one prime”) + correction factors
   - “shrinking” (paper’s Algorithms 1–2) to reduce `d` and/or `ell` mid-computation

4. **End-to-end amortized bootstrap pipeline**
   - LWE encrypt/decrypt + LWE key switching
   - pack `N` LWEs into one RLWE
   - implement `NTTDec` (Algorithm 9) and `MsgExtract` (Algorithm 10)
   - tie together into `Bootstrap` (Algorithm 11)
   - correctness tests + benchmark harness to match the paper’s reported metrics

5. **Keyset engineering**
   - avoid generating/storing all `p-1` automorphism keys unless needed
   - generate only the automorphisms required by the chosen INTT schedule (or generate-on-demand)

---

## Performance work areas (expected wins)

If you’re here to improve performance, these are the biggest levers:

- **Prime-length NTT efficiency**
  - reduce permutation overhead (consider Stockham autosort)
  - exploit `12288 = 4096×3` with tensor/six-step variants
  - improve vectorization (AVX2/AVX-512), reduce loads/stores

- **RNS limb count (`ell`)**
  - try larger primes (e.g., ~60-bit) to reduce `ell`, if arithmetic/noise budgets allow
  - ensure primes satisfy all required root-of-unity constraints

- **Avoid “full Galois keyset”**
  - restrict to the automorphisms actually used by the INTT recursion (depth `ρ`, radix `m`)
  - cache on demand

- **Reduce BaseExtend cost**
  - Base extension dominates many operations if done naively.
  - Consider precomputing constants, using faster mixed-radix transforms, or alternative extension strategies.

---

## Security / usage disclaimer

This repo is for **research and prototyping**:
- no constant-time guarantees,
- no side-channel protections,
- parameters are not audited for security,
- some cryptographic operations are currently incomplete stubs.

Do not use this code in production or to protect real secrets.

---

## References

- A. Guimarães, H. V. L. Pereira, B. van Leeuwen.  
  *Amortized bootstrapping revisited: Simpler, asymptotically-faster, implemented.*  
  Cryptology ePrint Archive, Report 2023/014. https://eprint.iacr.org/2023/014

---

## License

No license is currently specified for this repository. If you plan to share or reuse code, add an explicit license file.
